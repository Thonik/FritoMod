## Notes: Disabling this addon will disable all FritoMod-dependent addons.

-------------------------------------------------------------------------------
--
--  WoW API
--
-------------------------------------------------------------------------------

------------------------------------------
--  CreateFrame
------------------------------------------

CreateFrame("frameType", "globalName", parentFrame, "inherited,inherited,inherited");

frameType - The type of frame to create. Options include:
	FRAME - Generic frame, no extended capability.
	BUTTON - Interactive frame.
	STATUSBAR - 


globalName - Name of the frame that this frame will correspond to.
parentFrame - Convenience to make this frame attach, as a child, to the provided frame.
inherited - Not sure how these are different than frameTypes. These frames provided must be created using XML with virtual="true" in the tag. 

------------------------------------------
--  Frame:SetBackgroup
------------------------------------------

f:SetBackdrop({
  bgFile="Interface\\Tooltips\\UI-Tooltip-Background", 
  edgeFile="Interface\\Tooltips\\UI-Tooltip-Border", 
  tile=1, tileSize=10, edgeSize=10, 
  insets={left=3, right=3, top=3, bottom=3}
});


We abstract this rather ugly and low-level process. Options to do this include:

 - Internalize the process in DisplayObject. The process is the most direct, and mimicks Blizzard's way
 of doing.
 - Subclass DisplayObject. Most separated way, but lacks grace.
 - Create an entirely new class, that knows how to apply itself to a frame. It uses explicit values set on the frame.

-------------------------------------------------------------------------------
--
--  Validation
--
-------------------------------------------------------------------------------

DisplayObjects have a two-stage drawing process: Measurement via Measure(), and layout via UpdateLayout(). Each of these methods is called internally whenever the Stage iterates, and only if the DisplayObject has been invalidated in some way.

------------------------------------------
--  Types of Validation
------------------------------------------

Layout Invalidation - Something has changed internally to the DisplayObject that requires a redraw. This does not affect size, and thus will not propagate in either direction.

Examples: Color changes, Texture changes.

Child Size Invalidation - Something has changed internally to the DisplayObject that requires a redraw. This also will propagate up the display list, since parents could be resized accordingly. If the parent has children whose size is determined by available space (rather than explicitly set), then those children will also have to be redrawn.

Parent Size Invalidation - Something has changed to the parent that's changed its size. The parent will have to determine which children need to also be invalidated:

 - If the parent does no size allocation (That is, all DisplayObject's determine their own size), then only the parent's layout will be invalidated.
 - If the parent does size allocation (That is, some or all DisplayObject's are given a determined size), then those children whose sizes are determined will have to be laid out.

-------------------------------------------------------------------------------
--
--  Data Providers & Listeners
--
-------------------------------------------------------------------------------

------------------------------------------
--  Data Providers
------------------------------------------

External sources will create DataProviders whenever they want some information to be automatically distributed via FritoBars. DataProviders model some sort of data (From range-based data, a Unit's data, or a simple value), and provide an interface to update these values. Once these methods are called to change values on the DataProvider, an Update event will be triggered.

This Update event doesn't notify what value has changed - only that some change occurred. Typically, an InvalidateLayout is attached to the Update, so that the UI element is redrawn.

------------------------------------------
--  Data Registry: Tag Profiles
------------------------------------------

The DataRegistry provides a way for listeners and providers to broadcast their existence and attach to each other without knowing explicitly about each other. Each DataProvider, when registered, has a table of Tags, called a Tag Profile. These Profiles are arbitrary, and provide categories and values describing the DataProvider.

Any listener registered will also provide a Tag Profile. If any DataProviders are registered that match the categories given by the listener, they will be attached. Notice that the listener's Profile is the one used to match; any extra tags given by the DataProvider are ignored.

------------------------------------------
--  Data Listeners
------------------------------------------

Internally, a DataListener object is created when registering a listener, but this object isn't intended to be used by outside elements. Therefore, listeners merely need to provide a method to be called along with optional arguments, to use this system.

-------------------------------------------------------------------------------
--
--  Workflow for DataProvider/DataListener
--
-------------------------------------------------------------------------------

------------------------------------------
--  Using DataProviders
------------------------------------------

1. Create some object that's generating data. Instantiate a proper DataProvider to handle this data, with applicable tags:

local dp = DataProvider:new({data="Text", source="Test"}, "Hello, World!");

The DataProvider will automatically register itself with the DataRegistry, and will also automatically register itself with any existing listeners that have a matching Tag Profile. (Notice that data listeners' tags are used to match only. Extra tags provided by the DataProvider are ignored.)

2. Update the data in some way, using the methods provided by the DataProvider:

dp:SetValue("Goodbye, World!");

Calling these methods will fire the Update event, notifying all listeners that a change has been made. Notice that the event will not be fired if there was no actual change; Setting a DataProvider's value to itself will be silently returned with no event.

If you need to explicitly fire an event, use DataProvider's TriggerUpdate().

------------------------------------------
--  Using DataListeners
------------------------------------------

1. Create some object that's accepting data. Register it with the DataRegistry with your tags you're expecting.

Once your listener is registered, any existing DataProviders will be attached to your listener if they match your Tag Profile. A fake Update event will be created on this Attach to update your object with the data.

function myListener(dataProvider)
  debug(dataProvider:GetValue());
end;

DataRegistry:AddListener({source="Test"}, myListener);

2. Any subsequent updates from the DataProvider will also call your function, passing the DataProvider as the first and only argument. Also, any subsequent DataProviders registered that match your Profile will be registered, allowing you to easily aggregate data. You can make your listener exclusive by passing a true value in when registering your listener.

-------------------------------------------------------------------------------
--
--  Extended Workflow for DataProvider/DataListener
--
-------------------------------------------------------------------------------

------------------------------------------
--  TimerManager
------------------------------------------

A more practical example is a timer. We construct timer-like behavior using a DataProvider combined with the TimerManager library.

local dp = RangeDataProvider:new({type="Timer"}, 100);

local function timerFunc(totalElapsed, interval)
  dp:SetValue(dp:GetMaximum() - elapsed);
  if dp:GetValue() == 0 then
    TimerManager:UnregisterTimer(timerFunc);
  end;
end;

TimerManager:RegisterTimer(timerFunc);

Notice that while our Tag Profile for our RangeDataProvider defines a "type" variable, this is completely arbitrary, as all Tag Profiles are.

This also shows the very lazy constructor args for RangeDataProviders. Defining the initial value as 100 makes the maximum 100, and the minimum 0 by default.

The TimerManager library accepts only a function for registration to keep it small, so if an accurate self (or any other data) is needed, it must be done via closure. Timer functions fire before the Stage is validated, so you can update any animation using this library.

Showing the timer's duration can be done with a TextField:

local tf = TextField:new();
Stage.GetStage():AddChild(tf);

DataRegistry:AddListener({type="Timer"}, function(dataProvider)
  tf:SetText(dataProvider:GetValue());
end);
