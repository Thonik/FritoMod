







write a handler on style changes that updates things that keep track of what theyre associated with
then implement that handler in texture so that a list is made when people get added, and removed
when they change textures.

that way, when you change styles on the texture, the corresponding invalidatings will also be updated















-------------------------------------------------------------------------------
--
--  Scratch
--
-------------------------------------------------------------------------------

FritoBars
 - Central OnUpdate listener, activated when a bar exists, idle otherwise.

Bar:
	- Created from an external source. 
		- How is this attached to FritoBars to render more bars? 
		- How do categories work?

	- Configured like Bongos (Edit mode for changing, locked otherwise)
		- Snap to each other (Snappable areas shown in Edit Mode)

Bar Groups:
 - What does the object hierarchy look to get these?

Textures, Animations:
 - What does the object hierarchy look to get these?
 - How should these be OOP'd? Templates (Single reference handling its display on multiple objects?)
 - Spawned per object
 - Hybrid (Lots of little objects pointing to Templates) FLYWEIGHT

Alternative to Bongos Edit Mode:
	- Lab-like setup where a bar is shown and constructed.

Stage
 - Center of animation. OnUpdates flow through this element down the display list.

Does the Stage manage animation directly?
Should a manager walk the display list? Stage is the manager. All Containers manage
the display of their own children.

UI ASPECT:

SOURCE ASPECT:

External produces data --> 
	Plugin packages data into Source --> 
	Project receives Source via Event -->
	Source routed to created Bars -->
	Source invalidates Bars on its own changes -->
	Bars revalidate on the update -->
	Source dies when completed -->
	Bars remove themselves when their Source dies

1. External, undefined source (Threat Meters, Cooldown Libraries, DPS Meters, Native Events) emit data.

2. We bridge this undefined data to our project via dispatchers. Thes dispatchers register themselves with our project, who in return, attaches a callback to them for a known event.

3. These plugins generate Source objects from the data they are bridging. We receive them in our
listener.

4. We then route these Source objects to a respective bar. The type of bar created is based on the
type of Source object we've received. We will create different bars both based on user preferences 
and the type of Source. (e.g. Casting sources will be attached to a bar expecting a constant duration)

5. Once the Source is attached to a bar, the bar is made live. If the Source changes, it will invalidate all associated bars with it. Constant timers invalidate every frame until they are complete, whereas health bars invalidate only when the value changes.

6. Invalidated bars are queued up to be validated, and once done, will once again reflect the immediate state of their source.

